package application

// ----------------------------------------------------------------
// Automatically generated  "/application/externalmessage.go"
// ----------------------------------------------------------------
// Package              : application
// Object 			    : ExternalMessage (externalmessage)
// Endpoint 	        : ExternalMessage (Id)
// For Project          : github.com/mt1976/mwt-go-dev/
// ----------------------------------------------------------------
// Template Generator   : delinquentDysprosium [r4-21.12.31]
// Date & Time		    : 10/12/2021 at 16:18:37
// Who & Where		    : matttownsend on silicon.local
// ----------------------------------------------------------------

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"github.com/davecgh/go-spew/spew"
	core "github.com/mt1976/mwt-go-dev/core"
	"github.com/mt1976/mwt-go-dev/dao"
	dm "github.com/mt1976/mwt-go-dev/datamodel"
	logs "github.com/mt1976/mwt-go-dev/logs"
)

//ExternalMessage_HandlerList is the handler for the list page
func ExternalMessage_Handler(w http.ResponseWriter, r *http.Request) {
	// Mandatory Security Validation
	//Create NEW record =>POST
	// read=>GET
	// If the record exists then update else create a new record=>PUT
	// update/modify=>PATCH
	// delete=>DELETE
	logs.Processing("ExternalMessage_Handler")
	logs.Break()
	httpMethod := r.Method
	logs.Information("Method", httpMethod)
	logs.Break()

	inUTL := r.URL.Path
	w.Header().Set("Content-Type", "text/html")
	core.ServiceMessage(inUTL)

	//spew.Dump(t)

	//processID := t.MessageID

	//	if t.AppID != core.ApplicationProperties["applicationtoken"] {
	//		logs.Error("Application token mismatch", nil)
	//	}

	responseStatus := http.StatusOK

	//logs.Information(t.AppID, core.ApplicationProperties["applicationtoken"])
	//logs.Information("MessageID", processID)
	switch httpMethod {
	case http.MethodGet:
		externalMessage_MethodGet(w, r)

	case http.MethodPost:
		externalMessage_MethodPost(w, r)

	case http.MethodPut:
		externalMessage_MethodPost(w, r)
	case http.MethodDelete:

		externalMessage_MethodDelete(w, r)
	default:
		http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
	}

	//io.WriteString(w, strconv.Itoa(httpStatus))
	//r.Response.StatusCode = httpStatus
	logs.Information("HTTP Status", strconv.Itoa(responseStatus))

	//logs.Information("Application", "ExternalMessage_HandlerPost")
}

func externalMessage_MethodGet(w http.ResponseWriter, r *http.Request) {
	logs.Information("PATH", r.URL.Path)
	searchID := core.GetURLparam(r, dm.ExternalMessage_QueryString)
	logs.Information("GET", searchID)

	_, record, _ := dao.ExternalMessage_GetByID(searchID)
	spew.Dump(record)
	json_data, _ := json.Marshal(record)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(int(http.StatusOK))
	//fmt.Printf("json_data: %v\n", json_data)
	spew.Dump(json_data)
	w.Write(json_data)
	//	json.NewEncoder(w).Encode(json_data)
	// err := json.NewEncoder(w).Encode(json_data)
	// if err != nil {
	// 	http.Error(w, err.Error(), 500)
	// 	return
	// }
}

func externalMessage_MethodPost(w http.ResponseWriter, r *http.Request) {
	logs.Processing("POST")
	fmt.Printf("r.Body: %v\n", r.Body)

	decoder := json.NewDecoder(r.Body)
	var t dm.ExternalMessage
	err := decoder.Decode(&t)
	if err != nil {
		panic(err)
	}
	spew.Dump(t)
	err = dao.ExternalMessage_StoreSystem(t)
	logs.Processing("POST BACK")
	//logs.Information("POST", err.Error())
	if err != nil {
		//	panic(err)
	}
	logs.Success("POST")
}

func externalMessage_MethodDelete(w http.ResponseWriter, r *http.Request) {
	logs.Processing("DELETE")
	deleteID := core.GetURLparam(r, dm.ExternalMessage_QueryString)
	logs.Information("DELETE", deleteID)

	dao.ExternalMessage_Delete(deleteID)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(int(http.StatusOK))
	//fmt.Printf("json_data: %v\n", json_data)

	logs.Success("DELETE")
}
